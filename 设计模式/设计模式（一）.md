# 设计模式（一）

[toc]

产业强盛的标志——接口标准化

软件设计的金科玉律，复用

## 面向对象八大设计原则

设计原则比设计模式更重要（本质）

1. 依赖倒置原则（DIP）

   * 高层模块（稳定）不应该依赖于底层模块，二者都应该依赖于抽象
   * 抽象（稳定）不应该依赖与实现细节，实现细节应该依赖于抽象
   * 理解：变化的部分应该依赖于稳定的部分，而不是反过来，改进方法：提出抽象类

2. 开放封闭原则（OCP）

   * 对扩展开放，对更改封闭 

   * 类模块应该是可扩展的，但是不可修改

   * 理解：当需要增加一个新的功能的时候，不应该大幅度改变代码，而是在已有代码基础上“扩展”，如扩展一个类等等的做法

     ```C++
     class Circle : public Shape{//正确做法
         public:
         	virtual void Draw(const Graphics& g){
                 g.DrawCircle(Pens.Red,...);
             }
     }
     ```

     

3. 单一职责原则（SRP）

   * 一个类应该仅有一个引起它变化的原因
   * 变化的方向隐含着类的责任

4. Liskov替换原则（LSP)

   * 子类必须能够替换它们的基类（IS-A的另一种说法）
   * 继承表达类型抽象

5. 接口隔离原则（ISP）

   * 不应该强迫客户程序依赖它们不用的方法
   * 接口应该小而完备

6. 优先使用对象组合，而不是类继承

   * 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
   * 继承在某种程度上破坏了封装性，子类父类耦合度高
   * 而对象组合则只要求被组合的对象具有定义的接口，耦合度低
   * 理解：继承关系应该是一种“人类继承自动物继承自生物”这样的表达

7. 封装变化点

   * 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合
   * 理解：封装本质上是为了实现一侧变化一侧稳定的模式

8. 针对接口编程，而不是针对实现编程、

   * 不将变量类型声明为某个特定的具体类，而是声明为某个接口

   * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口

   * 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案

   * 理解：和依赖倒置原则相辅相成

     ```C++
     //声明为接口
     vector<Shape*> shape;
     //声明为具体的类
     vector<cricle> circle;
     vector<Rect> rect;
     ```

     

## Template Method

* 将变化和稳定合理结合的一种方法

```C++ 
//template_lib.cpp
//程序库开发人员
class Library{
public:
	//稳定 template method
    void Run(){
        
        Step1();

        if (Step2()) { //支持变化 ==> 虚函数的多态调用
            Step3(); 
        }

        for (int i = 0; i < 4; i++){
            Step4(); //支持变化 ==> 虚函数的多态调用
        }

        Step5();

    }
	virtual ~Library(){ }//在C++中写基类一定要写虚构函数，并且该虚构函数应该要是虚的

protected:
	
	void Step1() { //稳定
        //.....
    }
	void Step3() {//稳定
        //.....
    }
	void Step5() { //稳定
		//.....
	}

	virtual bool Step2() = 0;//变化
    virtual void Step4() =0; //变化
};
```
```C++
//template_app.cpp
//应用程序开发人员
class Application : public Library {
protected:
	virtual bool Step2(){
		//... 子类重写实现
    }

    virtual void Step4() {
		//... 子类重写实现
    }
};
int main()
	{
	    Library* pLib=new Application();
	    lib->Run();

		delete pLib;
	}
}
```

一般来说，库函数是“早”写的，app是“晚”写的，则有下面两种概念

* 早绑定：在app里面调用库函数
* 晚绑定：库函数调用app

>  定义一个操作中的算法骨架（稳定），而将一些步骤延迟（变化）到子类中。

理解：这句话基本实现为在父类中写一个虚函数之后在子类中重写实现

> Template Method使得子类可以不改变（复用）一个算法的结构，即可重定义（override重写）该算法的某些特定步骤
>
> ​		——《设计模式》GoF

Template Method需要现有一个可以复用的稳定的结构

